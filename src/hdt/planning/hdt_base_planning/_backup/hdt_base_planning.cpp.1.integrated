#include <ros/ros.h>
#include <signal.h>
#include <visualization_msgs/Marker.h>
#include <tf/transform_datatypes.h>
#include <stdlib.h>
#include <sstream>

// void computeRobPose(double objx, double objy, double objY,  double robx, double roby, double robY) 
void computeRobPose(double objx, double objy, double objY,  double& robx, double& roby, double& robY) 
{
	// COMPARISON OPTIONS
	// a) flag for pObs operation
	bool bCheckObs = true;
//  	bCheckObs = false;

	// b) arm position offset for computing pObs
	double armOffsety = 0.0;
	armOffsety = 0.5;
	armOffsety = 1.0;


	// policy for robot pose selection
	// 0) set search space
	// 1) probability of successul grasping
	// 2) distance to obstacles
	// 3) (workspace of hdt arm)
	// 4) multiplication of 1~3)
	// 5) if tied, one with minimum distance from robot
	// 6) conversion for /camera_link frame


	// 0) set search space (r,th,Y)
	// (r,th): polar coordinate with respect to the object with the center fixed at the origin and the nozzle aligned to 0 rad
	// (Y): orientation about z-axis
	int nDist = 5;		// r in [0.762:0.0762:1.0668] + camera offset
	int nAng = 12;		// th in [0:30:330]
// // // // // // 	int nYaw = 36;		// Y in [0:10:360]
	double distMin = 0.762, distStep = 0.0762, angMin = 0, angStep = 30.0/180.0*M_PI;
// 	double wTotxy = 0.7, wTotY = 0.3;		// weights for heuristically selecting the best among tiers

	double robxcur = robx, robycur = roby;//, robYcur = robY;
	double pTot[nDist][nAng], pGrasp[nDist][nAng], pObs[nDist][nAng], pWork[nDist][nAng];
	bool bTotMax[nDist][nAng];
	for (int i=0; i<nDist; i++)
		for (int j=0; j<nAng; j++)
		{
			pTot[i][j] = 1.0;	
			pGrasp[i][j] = 1.0;	
			pObs[i][j] = 1.0;	
			pWork[i][j] = 1.0;
			bTotMax[i][j] = false;
		}


	// 1) probability of successful grasping 
	pGrasp[0][0]  = 1.0;	pGrasp[1][0]  = .95;	pGrasp[2][0]  = .95;	pGrasp[3][0]  = 1.0;	pGrasp[4][0]  = .90;	
	pGrasp[0][1]  = .60;	pGrasp[1][1]  = .70;	pGrasp[2][1]  = .70;	pGrasp[3][1]  = .75;	pGrasp[4][1]  = .50;	
	pGrasp[0][2]  = .80;	pGrasp[1][2]  = .00;	pGrasp[2][2]  = .00;	pGrasp[3][2]  = .00;	pGrasp[4][2]  = .70;	
	pGrasp[0][3]  = .00;	pGrasp[1][3]  = 1.0;	pGrasp[2][3]  = 1.0;	pGrasp[3][3]  = 1.0;	pGrasp[4][3]  = .00;	
	pGrasp[0][4]  = .00;	pGrasp[1][4]  = .95;	pGrasp[2][4]  = .95;	pGrasp[3][4]  = 1.0;	pGrasp[4][4]  = 1.0;	
	pGrasp[0][5]  = 1.0;	pGrasp[1][5]  = 1.0;	pGrasp[2][5]  = 1.0;	pGrasp[3][5]  = .85;	pGrasp[4][5]  = 1.0;	
	pGrasp[0][6]  = 1.0;	pGrasp[1][6]  = 1.0;	pGrasp[2][6]  = 1.0;	pGrasp[3][6]  = .95;	pGrasp[4][6]  = 1.0;	
	pGrasp[0][7]  = 1.0;	pGrasp[1][7]  = .65;	pGrasp[2][7]  = .65;	pGrasp[3][7]  = .60;	pGrasp[4][7]  = .75;	
	pGrasp[0][8]  = 1.0;	pGrasp[1][8]  = .90;	pGrasp[2][8]  = .90;	pGrasp[3][8]  = .95;	pGrasp[4][8]  = .75;	
	pGrasp[0][9]  = .00;	pGrasp[1][9]  = .00;	pGrasp[2][9]  = .00;	pGrasp[3][9]  = .00;	pGrasp[4][9]  = .00;	
	pGrasp[0][10] = .00;	pGrasp[1][10] = .00;	pGrasp[2][10] = .00;	pGrasp[3][10] = .00;	pGrasp[4][10] = .85;	
	pGrasp[0][11] = 1.0;	pGrasp[1][11] = 1.0;	pGrasp[2][11] = .80;	pGrasp[3][11] = .80;	pGrasp[4][11] = .80;	


	// 2) probability not to collide with obstacles
	// depends on distance to obstacles considering the position offset wrt orientation
	// obstacle map; should be implemented here!; temporarily, obstacles of walls in a square room
	double obsxMin = -5, obsxMax = 5;
	double obsyMin = -5, obsyMax = 5;
	double distR2W;				// distance from robot to wall (obstacle)
	double distR2Wthr = 1.0;	// distance threshold for downweight of obstacle probability
	double orderDistR2W = 2.0;	// order of distR2W for obstacle probabilty relation
	for (int i=0; i<nDist; i++)
		for (int j=0; j<nAng; j++)
		{
			robx = objx + cos(objY + angMin + angStep*j)*(distMin + distStep*i) - sin(objY + angMin + angStep*j)*(armOffsety);
			roby = objy + sin(objY + angMin + angStep*j)*(distMin + distStep*i) + cos(objY + angMin + angStep*j)*(armOffsety);

			// for squared boundary & robot at center case only
			distR2W = std::min( std::min( std::max(0.0,obsxMax-robx), std::max(0.0,-(obsxMin-robx)) ), std::min( std::max(0.0,obsyMax-roby), std::max(0.0,-(obsyMin-roby)) ) );
// 			ROS_INFO("distR2W: %f",distR2W);

			pObs[i][j] = std::min(1.0, std::pow(distR2W/distR2Wthr,orderDistR2W));
			if (bCheckObs == false)
				pObs[i][j] = 1.0;	// for comparison only
		}


	// 3) robot arm workspace limit should be included here!




	// 4) total probability
	for (int i=0; i<nDist; i++)
		for (int j=0; j<nAng; j++)
			pTot[i][j] = pGrasp[i][j] * pObs[i][j] * pWork[i][j];	


	// 5) select max probability with min distance from robot
	// HEURISTICALLY, minimum difference in angular coordinate wrt object, then farthest from the origin of object
	double pTotMax = 0.0;
	for (int i=0; i<nDist; i++)
		for (int j=0; j<nAng; j++)
			if (pTot[i][j] > pTotMax)
				pTotMax = pTot[i][j];
	int iMax = 0, jMax = 0;		// indices for the final selection of robot pose
	int cntTotMax = 0;
	for (int i=0; i<nDist; i++)
		for (int j=0; j<nAng; j++)
			if (pTot[i][j] == pTotMax)
			{
				bTotMax[i][j] = true;
				iMax = i;
				jMax = j;
				cntTotMax++;
			}
	ROS_INFO("pTotMax: %f",pTotMax);
	ROS_INFO("cntTotMax: %d",cntTotMax);

	
	if (cntTotMax > 1)	// if more than one candidate poses are selected
					 	// (we can select poses with pTot higher than a THRESHOLD)
	{
		// a) sorting by difference of angular coordinates for current and desired poses
		// ASSUME? backward driving is allowed for husky
		// HEURISTIC: minimize angle difference between robot orientation (robY) and robot motion direction (angO2Rcur)
// 		double angO2Rcur = atan2(robycur-objy,robxcur-objx) - objY;	// current angular coordinate from object to robot
		double angO2Rcur = atan2(robycur-objy,robxcur-objx);	// current angular coordinate from object to robot
		double angO2Rdes, angO2Rerr, angO2RerrMin = M_PI;
		cntTotMax = 0;		// reinitialization for angular coordinate heuristic sorting
		for (int i=0; i<nDist; i++)
			for (int j=0; j<nAng; j++)
			{
				if (bTotMax[i][j] == true)
				{
					angO2Rdes = objY + angMin + angStep*j;		// desired angular coordinate from object to robot
					angO2Rerr = angO2Rdes - angO2Rcur;
					while(angO2Rerr >= M_PI)
						angO2Rerr -= 2*M_PI;
					while(angO2Rerr < -M_PI)
						angO2Rerr += 2*M_PI;
					
					if (fabs(angO2Rerr) <= angO2RerrMin)
					{
						angO2RerrMin = fabs(angO2Rerr);
						iMax = i;
						jMax = j;
						cntTotMax++;
// 						ROS_INFO("angO2RerrMin: %f    (i: %d, j: %d)",angO2RerrMin,i,j);
					}
					else
						bTotMax[i][j] = false;
				}
			}
		// update bTotMax[i][j]
		for (int i=0; i<nDist; i++)
			for (int j=0; j<nAng; j++)
				if (bTotMax[i][j] == true)
				{
					angO2Rdes = objY + angMin + angStep*j;
					angO2Rerr = angO2Rdes - angO2Rcur;
					while(angO2Rerr >= M_PI)
						angO2Rerr -= 2*M_PI;
					while(angO2Rerr < -M_PI)
						angO2Rerr += 2*M_PI;
					if (fabs(angO2Rerr) != angO2RerrMin)
					{
						bTotMax[i][j] = false;
						cntTotMax--;
					}
				}
		ROS_INFO("angO2RerrMin: %f",angO2RerrMin);
		ROS_INFO("cntTotMax: %d",cntTotMax);
			
		
		if (cntTotMax > 1)	// if more than one candidate poses are still selected
		{
			// b) sorting by distance from current and desired positions
			double robx, roby;
			double xysqerr, xysqerrMin = 1E10;		// distance from current to desired robot position
			cntTotMax = 0;		// reinitialization for angular coordinate heuristic sorting
			for (int i=0; i<nDist; i++)
				for (int j=0; j<nAng; j++)
				{
					if (bTotMax[i][j] == true)
					{
						robx = objx + cos(objY + angMin + angStep*j)*(distMin + distStep*i);
						roby = objy + sin(objY + angMin + angStep*j)*(distMin + distStep*i);

 						xysqerr = std::pow(robx-robxcur,2.0) + std::pow(roby-robycur,2.0);

						if (xysqerr <= xysqerrMin)
						{
							xysqerrMin = xysqerr;
							iMax = i;
							jMax = j;
							cntTotMax++;
// 							ROS_INFO("xysqerrMin: %f    (i: %d, j: %d)",xysqerrMin,i,j);
						}
						else
							bTotMax[i][j] = false;
					}
				}

			// OPTIONAL: update bTotMax[i][j]
			for (int i=0; i<nDist; i++)
				for (int j=0; j<nAng; j++)
					if (bTotMax[i][j] == true)
					{
						robx = objx + cos(objY + angMin + angStep*j)*(distMin + distStep*i);
						roby = objy + sin(objY + angMin + angStep*j)*(distMin + distStep*i);
 						xysqerr = std::pow(robx-robxcur,2.0) + std::pow(roby-robycur,2.0);
						if (xysqerr != xysqerrMin)
						{
							bTotMax[i][j] = false;
							cntTotMax--;
						}
					}
			ROS_INFO("xysqerrMin: %f",xysqerrMin);
			ROS_INFO("cntTotMax: %d",cntTotMax);
			if (cntTotMax > 1)
				ROS_INFO("CAUTION: Multiple candidate poses exist!");
		
		}
	}
	ROS_INFO("iMax: %d,    jMax: %d",iMax,jMax);

	// computing final desired robot pose with maximum pTot
	robx = objx + cos(objY + angMin + angStep*jMax)*(distMin + distStep*iMax);
	roby = objy + sin(objY + angMin + angStep*jMax)*(distMin + distStep*iMax);
	robY = objY + angMin + angStep*jMax - M_PI; 
	ROS_INFO("Object Pose: %f %f %f",objx,objy,objY*180/M_PI);
	ROS_INFO("Robot Pose: %f %f %f", robx,roby,robY*180/M_PI);


	// 6) conversion for /camera_link frame
	double robxswp=robx, robyswp=roby;
	robY = -robY;
	robx = -cos(robY)*robxswp + sin(robY)*robyswp;
	roby = -sin(robY)*robxswp - cos(robY)*robyswp;
	ROS_INFO("Robot Pose (cvt): %f %f %f", robx,roby,robY*180/M_PI);


}


void mySigintHandler(int sig)
{
	// All the default sigint handler does is call shutdown()
	ros::shutdown();
}

int main(int argc, char** argv)
{
	ros::init(argc, argv, "hdt_base_planning_node");
// 	ros::NodeHandle nh;
	ros::NodeHandle nh("~");

	// Override the default ros sigint handler.
	// This must be set after the first NodeHandle is created.
	signal(SIGINT, mySigintHandler);


// 	double objx = 1.0, objy = -0.5, objz = -0.05;	// for /base_link frame
	double objx = 1.0, objy = -0.5, objz = 0.1;		// for /camera_link frame
	double objR = M_PI/2, objP = 0.0, objY = 0.0;
	if (nh.hasParam("objx"))
		nh.getParam("objx",objx);
	if (nh.hasParam("objy"))
		nh.getParam("objy",objy);
	if (nh.hasParam("objY"))
	{
		nh.getParam("objY",objY);
		objY *= M_PI/180.0;			// when "objY" is in [deg]
	}
// 	ROS_INFO("Object Pose: %f %f %f",objx,objy,objY*180/M_PI);


	ros::Publisher vis_pub = nh.advertise<visualization_msgs::Marker>( "visualization_marker", 1 );

	visualization_msgs::Marker marker;
// 	marker.header.frame_id = "/base_link";
	marker.header.frame_id = "/camera_link";
	marker.header.stamp = ros::Time::now();
	marker.ns = "hdt_base_planning";
	marker.id = 0;
	marker.type = visualization_msgs::Marker::MESH_RESOURCE;
	marker.action = visualization_msgs::Marker::ADD;
	marker.pose.position.x = objx;
	marker.pose.position.y = objy;
	marker.pose.position.z = objz;

	tf::Quaternion q = tf::createQuaternionFromRPY(objR,objP,objY);
	marker.pose.orientation.x = q[0];
	marker.pose.orientation.y = q[1];
	marker.pose.orientation.z = q[2];
	marker.pose.orientation.w = q[3];

	// marker.scale.x = 10;	// gastank_c.dae
	// marker.scale.y = 10;
	// marker.scale.z = 10;
	marker.scale.x = 0.1;	// gastank_c_sparse.dae
	marker.scale.y = 0.1;
	marker.scale.z = 0.1;
	marker.color.a = 1.0;
	marker.color.r = 0.0;
	marker.color.g = 1.0;
	marker.color.b = 0.0;
	marker.lifetime = ros::Duration();

	//only if using a MESH_RESOURCE marker type:
	// marker.mesh_resource = "package://hdt_base_planning/meshes/gastank_c.dae";
// 	marker.mesh_resource = "package://hdt_base_planning/meshes/gastank_c_sparse.dae";
	marker.mesh_resource = "package://hdt/resource/meshes/gastank/gastank_c.dae";


	int cntPub = 0;
	ros::Rate r(10);
// 	while(ros::ok())
	while(cntPub < 5)
	{
		vis_pub.publish( marker );

		ros::spinOnce();
		r.sleep();
		cntPub++;
	}


	// COMPUTE ROBOT POSE HERE
//  	double robx=-2, roby=-1, robz=-0.65, robY=-0.3, robP=0, robR=0;
  	double robx=0, roby=0, robz=-0.65, robY=0, robP=0, robR=0;		// for /camera_link frame
	computeRobPose(objx,objy,objY, robx,roby,robY);		// obstacle map should be included here! 

	// VISUALIZE THE ROBOT 
//  	if (system("rosrun tf static_transform_publisher 04 03 -0.7 -0.3 0 0 kinect_frame_dummy camera_link 100"))
//  	if (system("/home/kimsk/ros/hdt_ws/src/hdt_base_planning/bin/hdt_base_planning_shell.sh 2 1 -0.7 -0.3 0 0"))
	std::stringstream str;
// 	str << "/home/kimsk/ros/hdt_ws/src/hdt_base_planning/bin/hdt_base_planning_shell.sh " <<  robx << " " << roby << " " << robz << " " << robY << " " << robP << " " << robR;
	str << "rosrun hdt hdt_base_planning_shell.sh " <<  robx << " " << roby << " " << robz << " " << robY << " " << robP << " " << robR;
// 	str << "/home/kimsk/ros/hdt_ws/src/hdt_base_planning/bin/hdt_base_planning_shell.sh " <<  robx << " " << roby << " " << robz << " " << robY << " " << robP << " " << robR << " >/dev/null";
	if (system(str.str().c_str())!=-1)
	{
		ROS_INFO("Robot Pose Established!\n");
	}


	nh.deleteParam("objx");
	nh.deleteParam("objy");
	nh.deleteParam("objY");

	return 0;
}
